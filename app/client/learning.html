<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Babylon Template</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>

        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    </head>

   <body>

    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

    <script>
        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

        // Add your code here matching the playground format
        const createScene = function () {
    
            const scene = new BABYLON.Scene(engine);
            //const base = generateBaseBig();
            const buttonPos = new BABYLON.Vector3(0,0,5);
            const buttonScale = 1;
            const sliderPos = new BABYLON.Vector3(5,0,0);
            const sliderScale = 3;
            const sequenceButtonPos = new BABYLON.Vector3(-2.5,0,-2.5);
            const sequenceButtonScale = 2;
            const sequence = ['red','blue','yellow','green'];
            generateSequenceButton(sequenceButtonPos,sequenceButtonScale,scene,sequence);
            generateButton(buttonPos,buttonScale,scene);
            generateSlider(sliderPos,sliderScale,scene,'vertical');
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0));
            camera.attachControl(canvas,true);
            camera.setPosition(new BABYLON.Vector3(0, 20, 0));
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));
            
            return scene;
        };

        const scene = createScene(); //Call the createScene function
        
        function random(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function generateButton(position, scaling, scene){
            const button = new BABYLON.MeshBuilder.CreateCylinder("button",{});
            const buttonMat = new BABYLON.StandardMaterial("buttonMat");
            const buttonScaling = new BABYLON.Vector3(3*scaling,0.5,3*scaling)
            const buttonPos = new BABYLON.Vector3(0,0,0);
            buttonPos['x'] = position['x'];
            buttonPos['y'] = position['y']+buttonScaling['y'];
            buttonPos['z'] = position['z'];
            buttonPos['z'] += 0.5*scaling;
            buttonMat.diffuseColor = new BABYLON.Color3(0,0,0.7);
            button.material = buttonMat;
            button.position = buttonPos;
            button.scaling = buttonScaling;

            generateBase(scaling,position,'diagonal');
            button.actionManager = new BABYLON.ActionManager(scene);
            button.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function () {console.log('cum');}
                )
            );
            button.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPointerOverTrigger,
                    function(){
                        buttonMat.diffuseColor = new BABYLON.Color3(0,0,1);
                    }
                )
            );
            button.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPointerOutTrigger,
                    function(){
                        buttonMat.diffuseColor = new BABYLON.Color3(0,0,0.7);
                    }
                ),
                
            );

        }

        function generateBase(scaling,position,type){
            const base = new BABYLON.MeshBuilder.CreateBox("base",{});
            const baseScaling = new BABYLON.Vector3(5,1,5);
            if(type == "diagonal"){
                baseScaling['x'] *= scaling;
                baseScaling['z'] *= scaling;
            }
            else if(type == 'horizontal'){
                baseScaling['x'] *= scaling;
            }
            else if(type == "vertical"){
                baseScaling['z'] *= scaling;
            }
            const baseMat = new BABYLON.StandardMaterial("baseMat");
            baseMat.diffuseColor = new BABYLON.Color3(1,1,1);
            base.position = position;
            base.scaling = baseScaling;
            base.material = baseMat;
            
            const points = [
                new BABYLON.Vector3(position['x']-baseScaling['x']/2,position['y']+baseScaling['y']/2,position['z']-baseScaling['z']/2),
                new BABYLON.Vector3(position['x']-baseScaling['x']/2,position['y']+baseScaling['y']/2,position['z']+baseScaling['z']/2),
                new BABYLON.Vector3(position['x']+baseScaling['x']/2,position['y']+baseScaling['y']/2,position['z']+baseScaling['z']/2),
                new BABYLON.Vector3(position['x']+baseScaling['x']/2,position['y']+baseScaling['y']/2,position['z']-baseScaling['z']/2),
                ];
            points.push(points[0]);
            const outline = BABYLON.MeshBuilder.CreateLines("outline",{points:points});
            outline.color = new BABYLON.Color3(1,0,0);
        }

        function generateSlider(position, scaling, scene, orientation){
            const sliderBase = new BABYLON.MeshBuilder.CreateBox("sliderBase",{});
            const sliderBaseMat = new BABYLON.StandardMaterial("sliderBaseMat");
            const sliderBaseScaling = new BABYLON.Vector3(1,0.5,1);
            if(orientation == 'vertical'){
                sliderBaseScaling['z'] *= scaling*3
            } else {
                sliderBaseScaling['x'] *= scaling*3
            }
            const sliderBasePos = new BABYLON.Vector3(0,0,0);
            sliderBasePos['x'] = position['x'];
            sliderBasePos['y'] = position['y']+sliderBaseScaling['y'];
            sliderBasePos['z'] = position['z'];


            const points = (orientation=='vertical')?
            [
                new BABYLON.Vector3(position['x']+sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']),
                new BABYLON.Vector3(position['x']-sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']),
            ]:[
                new BABYLON.Vector3(position['x'],sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']+sliderBaseScaling['z']/2),
                new BABYLON.Vector3(position['x'],sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']-sliderBaseScaling['z']/2),
            ]

            const midLine = BABYLON.MeshBuilder.CreateLines("midLine",{points:points});
            midLine.color = new BABYLON.Color3(1,0,0);
            sliderBaseMat.diffuseColor = new BABYLON.Color3(0,0,0);
            sliderBase.material = sliderBaseMat;
            sliderBase.position = sliderBasePos;
            sliderBase.scaling = sliderBaseScaling;


            const sliderButton = new BABYLON.MeshBuilder.CreateBox("sliderButton",{});
            const sliderButtonMat = new BABYLON.StandardMaterial("sliderButtonMat");
            const sliderButtonScaling = new BABYLON.Vector3(1,0.2,1);

            const maxValue = (orientation == 'vertical')? position['z']-sliderButton.scaling['z']/2+(sliderBase.scaling['z'])/2:position['x']-sliderButton.scaling['x']/2+(sliderBase.scaling['x'])/2
            const minValue = (orientation == 'vertical')? position['z']+sliderButton.scaling['z']/2-(sliderBase.scaling['z'])/2:position['x']+sliderButton.scaling['x']/2-(sliderBase.scaling['x'])/2
            const midValue = (orientation == 'vertical')? position['z']:position['x']
            const interval = (maxValue+sliderButtonScaling['x']/2-midValue)/2
            
            if(scaling != 1){
                const points1 = (orientation == 'vertical')?
                [
                new BABYLON.Vector3(position['x']+sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,midValue + interval),
                new BABYLON.Vector3(position['x']-sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,midValue + interval),
            ]:[
                new BABYLON.Vector3(midValue + interval,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']+sliderBaseScaling['z']/2),
                new BABYLON.Vector3(midValue + interval,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']-sliderBaseScaling['z']/2),
            ];
            
                const points2 = (orientation == 'vertical')?
                [
                new BABYLON.Vector3(position['x']+sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,midValue - interval),
                new BABYLON.Vector3(position['x']-sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,midValue - interval),
            ]:[
                new BABYLON.Vector3(midValue - interval,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']+sliderBaseScaling['z']/2),
                new BABYLON.Vector3(midValue - interval,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']-sliderBaseScaling['z']/2),
            ];

            const midMaxLine = BABYLON.MeshBuilder.CreateLines("midLine",{points:points1});
            const midMinLine = BABYLON.MeshBuilder.CreateLines("midMinLine",{points:points2})
            midMinLine.color = new BABYLON.Color3(1,0,0);
            midMaxLine.color = new BABYLON.Color3(1,0,0);
            }

            sliderButtonMat.diffuseColor = new BABYLON.Color3(0,0,0.7);
            sliderButton.material = sliderButtonMat;
            sliderButton.scaling = sliderButtonScaling;
            sliderButton.position = new BABYLON.Vector3(position['x'],sliderBasePos['y']+sliderBase.scaling['y']/2+sliderButton.scaling['y']/2,position['z']);
            sliderButton.actionManager = new BABYLON.ActionManager(scene);
            sliderButton.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPointerOverTrigger,
                    function(){
                        sliderButtonMat.diffuseColor = new BABYLON.Color3(0,0,1);
                    }
                )
            );
            sliderButton.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPointerOutTrigger,
                    function(){
                        sliderButtonMat.diffuseColor = new BABYLON.Color3(0,0,0.7);
                    }
                ),
                
            );

            if(orientation=='horizontal'){
                generateBase(scaling,position,'horizontal');
            } else {
                generateBase(scaling,position,'vertical');

            }
            const pointerDragBehavior = (orientation == "vertical")? new BABYLON.PointerDragBehavior({dragAxis: new BABYLON.Vector3(0,0,1)}):new BABYLON.PointerDragBehavior({dragAxis: new BABYLON.Vector3(1,0,0)});
            sliderButton.addBehavior(pointerDragBehavior);
            
            pointerDragBehavior.onDragEndObservable.add((event)=>{
                let sliderPos = (orientation == 'vertical')? Math.round((sliderButton.position['z'])*10)/10 : Math.round(sliderButton.position['x']*10)/10;
                console.log(sliderPos)
                // Do something if certain threshold is met
                sliderThresholdCheck(sliderPos,scaling,maxValue,minValue, midValue,interval);
                console.log(event);
             })
            pointerDragBehavior.validateDrag = (targetPosition)=>{
                if(orientation == 'vertical'){
                    if(targetPosition.z < minValue){
                        targetPosition.z = minValue
                    }
                    
                    if(targetPosition.z > maxValue){
                        return false
                    }else{
                        return true
                    }
            } else {
                if(targetPosition.x < minValue){
                        targetPosition.x = minValue
                    }
                    
                    if(targetPosition.x > maxValue){
                        return false
                    }else{
                        return true
                    }
            }
            }
        }

        function sliderThresholdCheck(sliderPos, scaling, maxValue, minValue, midValue, interval){
            const offSet = 0.2;
            
            if(sliderPos <= midValue+offSet && sliderPos >= midValue-offSet){
                console.log('mid');
            }

            else if(sliderPos == minValue){
                console.log('min')
            }

            else if(sliderPos == maxValue){
                console.log('max')
            }

            else if(scaling != 1){
                if(sliderPos <= midValue+offSet+interval && sliderPos >= midValue+interval-offSet){
                    console.log('mid-max')
                }
                if(sliderPos <= midValue+offSet-interval && sliderPos >= midValue-interval-offSet){
                    console.log('mid-min')
                }
            }

        }

        function generateSequenceButton(position, scaling, scene, sequence){
            generateBase(scaling,position,'diagonal');
            const redButton = new BABYLON.MeshBuilder.CreateBox('redButton',{});
            const greenButton = new BABYLON.MeshBuilder.CreateBox('greenButton',{});
            const yellowButton = new BABYLON.MeshBuilder.CreateBox('yellowButton',{});
            const blueButton = new BABYLON.MeshBuilder.CreateBox('blueButton',{});
            let sequenceButton = [];
            sequenceButton.push(redButton);
            sequenceButton.push(greenButton);
            sequenceButton.push(yellowButton);
            sequenceButton.push(blueButton);
            const redButtonMat = new BABYLON.StandardMaterial("redButtonMat");
            const greenButtonMat = new BABYLON.StandardMaterial("greenButtonMat");
            const yellowButtonMat = new BABYLON.StandardMaterial("yellowButtonMat");
            const blueButtonMat = new BABYLON.StandardMaterial("blueButtonMat");
            redButtonMat.diffuseColor = new BABYLON.Color3(0.5,0,0);
            greenButtonMat.diffuseColor = new BABYLON.Color3(0,0.5,0);
            yellowButtonMat.diffuseColor = new BABYLON.Color3(0.5,0.5,0);
            blueButtonMat.diffuseColor = new BABYLON.Color3(0,0,0.5);
            let sequenceButtonMat = [];
            sequenceButtonMat.push(redButtonMat);
            sequenceButtonMat.push(greenButtonMat);
            sequenceButtonMat.push(yellowButtonMat);
            sequenceButtonMat.push(blueButtonMat);
            
            for(let i = 0; i < sequenceButton.length; i++){
                sequenceButton[i].material = sequenceButtonMat[i];
            }
            
            
            const sequenceButtonScaling = new BABYLON.Vector3(1.5*scaling,0.5,1.5*scaling);

            for(let i = 0; i < sequenceButton.length; i++){
                sequenceButton[i].scaling = sequenceButtonScaling;
            }
            
            let sequenceButtonPos = [];
            sequenceButtonPos.push(new BABYLON.Vector3(position['x']+sequenceButtonScaling['x']/2,sequenceButtonScaling['y'],position['z']-sequenceButtonScaling['z']/2));
            sequenceButtonPos.push(new BABYLON.Vector3(position['x']+sequenceButtonScaling['x']/2,sequenceButtonScaling['y'],position['z']+sequenceButtonScaling['z']/2));
            sequenceButtonPos.push(new BABYLON.Vector3(position['x']-sequenceButtonScaling['x']/2,sequenceButtonScaling['y'],position['z']+sequenceButtonScaling['z']/2));
            sequenceButtonPos.push(new BABYLON.Vector3(position['x']-sequenceButtonScaling['x']/2,sequenceButtonScaling['y'],position['z']-sequenceButtonScaling['z']/2));
            
            for(let i = 0; i < sequenceButton.length;i++){
                let randomPos = sequenceButtonPos[Math.floor(Math.random() * sequenceButtonPos.length)];
                sequenceButton[i].position = randomPos;
                sequenceButtonPos = sequenceButtonPos.filter(function(e){return e != randomPos});
                sequenceButton[i].actionManager = new BABYLON.ActionManager(scene);
            }
            
            let userSequence = [];
            let result = 0;
            
            redButton.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function(){
                        if(userSequence.includes('red') == false && result != true){
                            redButtonMat.diffuseColor = new BABYLON.Color3(1,0,0);
                            userSequence.push('red');
                            result = checkSequenceResult(sequence, userSequence, sequenceButtonMat);
                            if(result == -1) userSequence = [];  
                        }
                    }
                )
            );
            greenButton.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function(){
                        if(userSequence.includes('green') == false && result != true){
                            greenButtonMat.diffuseColor = new BABYLON.Color3(0,1,0);
                            userSequence.push('green');
                            result = checkSequenceResult(sequence, userSequence, sequenceButtonMat);
                            if(result == -1) userSequence = [];  
                        }
                    }
                )
            );
            yellowButton.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function(){
                        if(userSequence.includes('yellow') == false && result != true){
                            yellowButtonMat.diffuseColor = new BABYLON.Color3(1,1,0);
                            userSequence.push('yellow');
                            result = checkSequenceResult(sequence, userSequence, sequenceButtonMat); 
                            if(result == -1) userSequence = [];  
                        }
                    }
                )
            );
            blueButton.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function(){
                        if(userSequence.includes('blue') == false && result != true){
                            blueButtonMat.diffuseColor = new BABYLON.Color3(0,0,1);
                            userSequence.push('blue');
                            result = checkSequenceResult(sequence, userSequence, sequenceButtonMat);  
                            if(result == -1) {userSequence = [];}  
                        }
                    }
                )
            );
                    
        }

        function checkSequenceResult(sequence, userSequence, sequenceButtonMat){
            if(userSequence.length == 4){
                for(let i = 0; i < userSequence.length; i++){
                    if(sequence[i] != userSequence[i]) {
                        console.log('Incorrect Sequence');
                        sequenceButtonMat[0].diffuseColor = new BABYLON.Color3(0.5,0,0);
                        sequenceButtonMat[1].diffuseColor = new BABYLON.Color3(0,0.5,0);
                        sequenceButtonMat[2].diffuseColor = new BABYLON.Color3(0.5,0.5,0);
                        sequenceButtonMat[3].diffuseColor = new BABYLON.Color3(0,0,0.5);
                        console.log(sequence);
                        return -1;
                    }
                }
                console.log('Correct Sequence');
                return 1;
            } else return 0;
            
        }
        function generateBaseBig(){
            const base = new BABYLON.MeshBuilder.CreateBox("box",{width:15,depth:15});
            const points1 = [
                new BABYLON.Vector3(-7.5,0.51,2.5),
                new BABYLON.Vector3(7.5,0.51,2.5),
                new BABYLON.Vector3(7.5,0.51,-2.5),
                new BABYLON.Vector3(-7.5,0.51,-2.5),
                ];
            points1.push(points1[0]);
            const line1 = BABYLON.MeshBuilder.CreateLines("lines1",{points:points1});
            line1.color = new BABYLON.Color3(0,0,0);

            const points2 = [
                new BABYLON.Vector3(-2.5,0.51,7.5),
                new BABYLON.Vector3(2.5,0.51,7.5),
                new BABYLON.Vector3(2.5,0.51,-7.5),
                new BABYLON.Vector3(-2.5,0.51,-7.5),
                ];
            points2.push(points2[0]);
            const line2 = BABYLON.MeshBuilder.CreateLines("lines2",{points:points2});
            line2.color = new BABYLON.Color3(0,0,0);

            return base;
        }
        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
                scene.render();
        });

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });
    </script>

   </body>

</html>