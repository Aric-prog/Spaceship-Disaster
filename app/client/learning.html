<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Babylon Template</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>

        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    </head>

   <body>

    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

    <script>
        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

        // Add your code here matching the playground format
        const createScene = function () {
    
            const scene = new BABYLON.Scene(engine);
            //const base = generateBaseBig();
            const buttonPos = new BABYLON.Vector3(0,0,5);
            const buttonScale = 1;
            const sliderPos = new BABYLON.Vector3(5,0,0);
            const sliderScale = 3;
            const sequenceButtonPos = new BABYLON.Vector3(0,0,0);
            const sequenceButtonScale = 1;
            const leverPos = new BABYLON.Vector3(-5,0,5);
            const leverScale = 1;
            const rotatingDialPos = new BABYLON.Vector3(-5,0,0);
            const rotatingDialScale = 1;
            const joyStickPos = new BABYLON.Vector3(0,0,-5)
            const joyStickScale = 1;
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0));
            camera.attachControl(canvas,true);
            camera.setPosition(new BABYLON.Vector3(0, 20, 0));
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));
            generateJoyStick(joyStickPos,joyStickScale,scene);
            generateRotatingDial(rotatingDialPos,rotatingDialScale,scene,camera);
            generateLever(leverPos,leverScale,scene,'diagonal');
            generateSequenceButton(sequenceButtonPos,sequenceButtonScale,scene);
            generateButton(buttonPos,buttonScale,scene);
            generateSlider(sliderPos,sliderScale,scene,'vertical');
            
            
            return scene;
        };

        const scene = createScene(); //Call the createScene function
        
        function generateButton(position, scaling, scene){
            const baseScaling = generateBase(scaling,position,'diagonal');
            const button = new BABYLON.MeshBuilder.CreateCylinder("button",{});
            const buttonMat = new BABYLON.StandardMaterial("buttonMat");
            const buttonScaling = new BABYLON.Vector3(3*scaling,0.5,3*scaling)
            const buttonPos = new BABYLON.Vector3(0,0,0);
            buttonPos['x'] = position['x'];
            buttonPos['y'] = baseScaling['y']/2;
            buttonPos['z'] = position['z'];
            buttonPos['z'] += 0.5*scaling;
            buttonMat.diffuseColor = new BABYLON.Color3(0,0,0.6);
            button.material = buttonMat;
            button.position = buttonPos;
            button.scaling = buttonScaling;

            button.actionManager = new BABYLON.ActionManager(scene);
            let downFlag = false;
            button.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function () {
                        console.log('cum');
                        scene.registerBeforeRender(buttonCallback);
                    }
                )
            );
            
            function buttonCallback(){
                if(downFlag == false){
                    button.position.y -= 0.01;
                    if(button.position.y < 0.2){downFlag = true}
                }
                else{
                    button.position.y += 0.01;
                    if(button.position.y > 0.49){
                        downFlag = false;
                        scene.unregisterBeforeRender(buttonCallback);}
                }
            }
            onHover(button,buttonMat,'blue');

        }

        function generateBase(scaling,position,type){
            const base = new BABYLON.MeshBuilder.CreateBox("base",{});
            const baseScaling = new BABYLON.Vector3(5,1,5);
            if(type == "diagonal"){
                baseScaling['x'] *= scaling;
                baseScaling['z'] *= scaling;
            }
            else if(type == 'horizontal'){
                baseScaling['x'] *= scaling;
            }
            else if(type == "vertical"){
                baseScaling['z'] *= scaling;
            }
            const baseMat = new BABYLON.StandardMaterial("baseMat");
            baseMat.diffuseColor = new BABYLON.Color3(1,1,1);
            base.position = position;
            base.scaling = baseScaling;
            base.material = baseMat;
            
            const points = [
                new BABYLON.Vector3(position['x']-baseScaling['x']/2,position['y']+baseScaling['y']/2,position['z']-baseScaling['z']/2),
                new BABYLON.Vector3(position['x']-baseScaling['x']/2,position['y']+baseScaling['y']/2,position['z']+baseScaling['z']/2),
                new BABYLON.Vector3(position['x']+baseScaling['x']/2,position['y']+baseScaling['y']/2,position['z']+baseScaling['z']/2),
                new BABYLON.Vector3(position['x']+baseScaling['x']/2,position['y']+baseScaling['y']/2,position['z']-baseScaling['z']/2),
                ];
            points.push(points[0]);
            const outline = BABYLON.MeshBuilder.CreateLines("outline",{points:points});
            outline.color = new BABYLON.Color3(0,0,0);
            return baseScaling;
        }

        function generateSlider(position, scaling, scene, orientation){
            const baseScaling = (orientation == 'horizontal')? generateBase(scaling,position,'horizontal'):generateBase(scaling,position,'vertical');
            const sliderBase = new BABYLON.MeshBuilder.CreateBox("sliderBase",{});
            const sliderBaseMat = new BABYLON.StandardMaterial("sliderBaseMat");
            const sliderBaseScaling = new BABYLON.Vector3(1,0.5,1);
            if(orientation == 'vertical'){
                sliderBaseScaling['z'] *= scaling*3
            } else {
                sliderBaseScaling['x'] *= scaling*3
            }
            const sliderBasePos = new BABYLON.Vector3(0,0,0);
            sliderBasePos['x'] = position['x'];
            sliderBasePos['y'] = baseScaling['y']/2;
            sliderBasePos['z'] = position['z'];


            const points = (orientation=='vertical')?
            [
                new BABYLON.Vector3(position['x']+sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']),
                new BABYLON.Vector3(position['x']-sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']),
            ]:[
                new BABYLON.Vector3(position['x'],sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']+sliderBaseScaling['z']/2),
                new BABYLON.Vector3(position['x'],sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']-sliderBaseScaling['z']/2),
            ]

            const midLine = BABYLON.MeshBuilder.CreateLines("midLine",{points:points});
            midLine.color = new BABYLON.Color3(1,0,0);
            sliderBaseMat.diffuseColor = new BABYLON.Color3(0,0,0);
            sliderBase.material = sliderBaseMat;
            sliderBase.position = sliderBasePos;
            sliderBase.scaling = sliderBaseScaling;


            const sliderButton = new BABYLON.MeshBuilder.CreateBox("sliderButton",{});
            const sliderButtonMat = new BABYLON.StandardMaterial("sliderButtonMat");
            const sliderButtonScaling = new BABYLON.Vector3(1,0.2,1);

            const maxValue = (orientation == 'vertical')? position['z']-sliderButton.scaling['z']/2+(sliderBase.scaling['z'])/2:position['x']-sliderButton.scaling['x']/2+(sliderBase.scaling['x'])/2
            const minValue = (orientation == 'vertical')? position['z']+sliderButton.scaling['z']/2-(sliderBase.scaling['z'])/2:position['x']+sliderButton.scaling['x']/2-(sliderBase.scaling['x'])/2
            const midValue = (orientation == 'vertical')? position['z']:position['x']
            const interval = (maxValue+sliderButtonScaling['x']/2-midValue)/2
            
            if(scaling != 1){
                const points1 = (orientation == 'vertical')?
                [
                new BABYLON.Vector3(position['x']+sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,midValue + interval),
                new BABYLON.Vector3(position['x']-sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,midValue + interval),
            ]:[
                new BABYLON.Vector3(midValue + interval,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']+sliderBaseScaling['z']/2),
                new BABYLON.Vector3(midValue + interval,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']-sliderBaseScaling['z']/2),
            ];
            
                const points2 = (orientation == 'vertical')?
                [
                new BABYLON.Vector3(position['x']+sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,midValue - interval),
                new BABYLON.Vector3(position['x']-sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,midValue - interval),
            ]:[
                new BABYLON.Vector3(midValue - interval,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']+sliderBaseScaling['z']/2),
                new BABYLON.Vector3(midValue - interval,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']-sliderBaseScaling['z']/2),
            ];

            const midMaxLine = BABYLON.MeshBuilder.CreateLines("midLine",{points:points1});
            const midMinLine = BABYLON.MeshBuilder.CreateLines("midMinLine",{points:points2})
            midMinLine.color = new BABYLON.Color3(1,0,0);
            midMaxLine.color = new BABYLON.Color3(1,0,0);
            }

            sliderButtonMat.diffuseColor = new BABYLON.Color3(0,0,0.6);
            sliderButton.material = sliderButtonMat;
            sliderButton.scaling = sliderButtonScaling;
            sliderButton.position = new BABYLON.Vector3(position['x'],sliderBasePos['y']+sliderBase.scaling['y']/2+sliderButton.scaling['y']/2,position['z']);
            sliderButton.actionManager = new BABYLON.ActionManager(scene);
            onHover(sliderButton,sliderButtonMat,'blue')

            const pointerDragBehavior = (orientation == "vertical")? new BABYLON.PointerDragBehavior({dragAxis: new BABYLON.Vector3(0,0,1)}):new BABYLON.PointerDragBehavior({dragAxis: new BABYLON.Vector3(1,0,0)});
            sliderButton.addBehavior(pointerDragBehavior);
           
            pointerDragBehavior.onDragEndObservable.add((event)=>{
                let sliderPos = (orientation == 'vertical')? Math.round((sliderButton.position['z'])*10)/10 : Math.round(sliderButton.position['x']*10)/10;
                console.log(sliderPos)
                sliderThresholdCheck(sliderPos,scaling,maxValue,minValue, midValue,interval);
                //console.log(event);
             })
            pointerDragBehavior.validateDrag = (targetPosition)=>{
                if(orientation == 'vertical'){
                    if(targetPosition.z < minValue){
                        targetPosition.z = minValue
                    }
                    
                    if(targetPosition.z > maxValue){
                        return false
                    }else{
                        return true
                    }
            } else {
                if(targetPosition.x < minValue){
                        targetPosition.x = minValue
                    }
                    
                    if(targetPosition.x > maxValue){
                        return false
                    }else{
                        return true
                    }
            }
            }
        }

        function sliderThresholdCheck(sliderPos, scaling, maxValue, minValue, midValue, interval){
            const offSet = 0.2;
            
            if(sliderPos <= midValue+offSet && sliderPos >= midValue-offSet){
                console.log('mid');
            }

            else if(sliderPos == minValue){
                console.log('min')
            }

            else if(sliderPos == maxValue){
                console.log('max')
            }

            else if(scaling != 1){
                if(sliderPos <= midValue+offSet+interval && sliderPos >= midValue+interval-offSet){
                    console.log('mid-max')
                }
                if(sliderPos <= midValue+offSet-interval && sliderPos >= midValue-interval-offSet){
                    console.log('mid-min')
                }
            }

        }

        function generateSequenceButton(position, scaling, scene){
            const baseScaling = generateBase(scaling,position,'diagonal');
            const redButton = new BABYLON.MeshBuilder.CreateBox('redButton',{});
            const greenButton = new BABYLON.MeshBuilder.CreateBox('greenButton',{});
            const yellowButton = new BABYLON.MeshBuilder.CreateBox('yellowButton',{});
            const blueButton = new BABYLON.MeshBuilder.CreateBox('blueButton',{});
            let sequenceButton = [];
            sequenceButton.push(redButton);
            sequenceButton.push(greenButton);
            sequenceButton.push(yellowButton);
            sequenceButton.push(blueButton);
            const redButtonMat = new BABYLON.StandardMaterial("redButtonMat");
            const greenButtonMat = new BABYLON.StandardMaterial("greenButtonMat");
            const yellowButtonMat = new BABYLON.StandardMaterial("yellowButtonMat");
            const blueButtonMat = new BABYLON.StandardMaterial("blueButtonMat");
            redButtonMat.diffuseColor = new BABYLON.Color3(0.5,0,0);
            greenButtonMat.diffuseColor = new BABYLON.Color3(0,0.5,0);
            yellowButtonMat.diffuseColor = new BABYLON.Color3(0.5,0.5,0);
            blueButtonMat.diffuseColor = new BABYLON.Color3(0,0,0.5);
            let sequenceButtonMat = [];
            sequenceButtonMat.push(redButtonMat);
            sequenceButtonMat.push(greenButtonMat);
            sequenceButtonMat.push(yellowButtonMat);
            sequenceButtonMat.push(blueButtonMat);
            
            for(let i = 0; i < sequenceButton.length; i++){
                sequenceButton[i].material = sequenceButtonMat[i];
            }
            
            
            const sequenceButtonScaling = new BABYLON.Vector3(1.5*scaling,0.5,1.5*scaling);

            for(let i = 0; i < sequenceButton.length; i++){
                sequenceButton[i].scaling = sequenceButtonScaling;
            }
            
            let sequenceButtonPos = [];
            sequenceButtonPos.push(new BABYLON.Vector3(position['x']+sequenceButtonScaling['x']/2,baseScaling['y']/2,position['z']-sequenceButtonScaling['z']/2));
            sequenceButtonPos.push(new BABYLON.Vector3(position['x']+sequenceButtonScaling['x']/2,baseScaling['y']/2,position['z']+sequenceButtonScaling['z']/2));
            sequenceButtonPos.push(new BABYLON.Vector3(position['x']-sequenceButtonScaling['x']/2,baseScaling['y']/2,position['z']+sequenceButtonScaling['z']/2));
            sequenceButtonPos.push(new BABYLON.Vector3(position['x']-sequenceButtonScaling['x']/2,baseScaling['y']/2,position['z']-sequenceButtonScaling['z']/2));
            
            for(let i = 0; i < sequenceButton.length;i++){
                let randomPos = sequenceButtonPos[Math.floor(Math.random() * sequenceButtonPos.length)];
                sequenceButton[i].position = randomPos;
                sequenceButtonPos = sequenceButtonPos.filter(function(e){return e != randomPos});
                sequenceButton[i].actionManager = new BABYLON.ActionManager(scene);
            }
            
            let userSequence = [];
            
            redButton.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function(){
                        if(userSequence.includes('red') == false){
                            redButtonMat.diffuseColor = new BABYLON.Color3(1,0,0);
                            userSequence.push('red');
                            userSequence = submitSequenceResult(userSequence, sequenceButtonMat);    
                        }
                    }
                )
            );
            greenButton.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function(){
                        if(userSequence.includes('green') == false){
                            greenButtonMat.diffuseColor = new BABYLON.Color3(0,1,0);
                            userSequence.push('green');
                            userSequence = submitSequenceResult(userSequence, sequenceButtonMat);    
                        }
                    }
                )
            );
            yellowButton.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function(){
                        if(userSequence.includes('yellow') == false){
                            yellowButtonMat.diffuseColor = new BABYLON.Color3(1,1,0);
                            userSequence.push('yellow');
                            userSequence = submitSequenceResult(userSequence, sequenceButtonMat);    
                        }
                    }
                )
            );
            blueButton.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function(){
                        if(userSequence.includes('blue') == false){
                            blueButtonMat.diffuseColor = new BABYLON.Color3(0,0,1);
                            userSequence.push('blue');
                            userSequence = submitSequenceResult(userSequence, sequenceButtonMat);
                            
                        }
                    }
                )
            );
        }

        function submitSequenceResult(userSequence, sequenceButtonMat){
            if(userSequence.length == 4){
                sequenceButtonMat[0].diffuseColor = new BABYLON.Color3(0.5,0,0);
                sequenceButtonMat[1].diffuseColor = new BABYLON.Color3(0,0.5,0);
                sequenceButtonMat[2].diffuseColor = new BABYLON.Color3(0.5,0.5,0);
                sequenceButtonMat[3].diffuseColor = new BABYLON.Color3(0,0,0.5);
            
                console.log(userSequence);
                userSequence = [];
                return userSequence;
            } else {return userSequence;}
        }
        
        function generateLever(position, scaling, scene, orientation){
            const baseScaling = generateBase(scaling,position,orientation);
            const lever = new BABYLON.MeshBuilder.CreateBox('lever',{});
            const leverMat = new BABYLON.StandardMaterial('leverMat');
            const leverPos = new BABYLON.Vector3(0,0,0);
            const leverScaling = new BABYLON.Vector3(3,0.4,1);
            if(orientation == 'diagonal'){
                leverScaling['x'] *= scaling;
                leverScaling['z'] *= scaling;
            } else if(orientation == 'vertical'){
                leverScaling['z'] *= scaling;
            } else {leverScaling['x'] *= scaling}
            
            let leverState = 0;
            leverPos['x'] = position['x']
            leverPos['y'] = baseScaling['y']/2
            leverPos['z'] = position['z']
            leverMat.diffuseColor = new BABYLON.Color3(0,0,0.6);
            lever.material = leverMat;
            lever.position = leverPos;
            lever.scaling = leverScaling;
            lever.rotation.z = Math.PI*(30/180);
            const leverStatus = new BABYLON.MeshBuilder.CreateSphere("sphere", {slice: 0.5, sideOrientation: BABYLON.Mesh.DOUBLESIDE});
            const leverStatusMat = new BABYLON.StandardMaterial('leverStatusMat');
            leverStatusMat.diffuseColor = new BABYLON.Color3(1,0,0);
            leverStatus.material = leverStatusMat;
            const leverStatusPos = new BABYLON.Vector3(0,0,0);
            leverStatusPos['x'] = position['x'] - baseScaling['x']/2 + 0.5*scaling
            leverStatusPos['y'] = lever.scaling['y']-0.2
            leverStatusPos['z'] = position['z'] + baseScaling['z']/2 - 0.5*scaling
            leverStatus.position = leverStatusPos;

            lever.actionManager = new BABYLON.ActionManager(scene);
            lever.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function () {
                        if(leverState == 0){
                            leverState = 1;
                            leverStatusMat.diffuseColor = new BABYLON.Color3(0,1,0);
                            console.log('yummy');
                            scene.registerBeforeRender(leverCallback);
                        }
                        else {
                            leverState = 0;
                            leverStatusMat.diffuseColor = new BABYLON.Color3(1,0,0);
                            console.log('tummy');
                            scene.registerBeforeRender(leverCallback);
                        }
                    }
                )
            );
            function leverCallback(){
                if(leverState == 1){
                    lever.rotation.z += Math.PI*(10/180);
                    if(lever.rotation.z > Math.PI*(150/180)){
                        scene.unregisterBeforeRender(leverCallback);
                    }
                } else{
                    lever.rotation.z -= Math.PI*(10/180);;
                    if(lever.rotation.z < Math.PI*(30/180)){
                        scene.unregisterBeforeRender(leverCallback);
                    }
                }
            }
            onHover(lever,leverMat,'blue');




        }
        
        function generateRotatingDial(position, scaling,scene,camera){
            const baseScaling = generateBase(scaling,position,'diagonal');
            const dialBase = new BABYLON.MeshBuilder.CreateCylinder("dialBase",{})
            const dialPointer = new BABYLON.MeshBuilder.CreateBox("dialPointer",{});
            const dialPointerScaling = new BABYLON.Vector3(2.3*scaling,0.5,0.5*scaling);
            const dialBaseScaling = new BABYLON.Vector3(2.3*scaling,0.4,2.3*scaling);
            const dialPointerPos = new BABYLON.Vector3(0,0,0);
            const dialBasePos = new BABYLON.Vector3(0,0,0);
            const dialBaseMat = new BABYLON.StandardMaterial('dialBaseMat');
            const dialPointerMat = new BABYLON.StandardMaterial('dialPointerMat');
            dialPointer.rotation.z = Math.PI*(15/180)
            dialBaseMat.diffuseColor = new BABYLON.Color3(0,0,0);
            dialPointerMat.diffuseColor = new BABYLON.Color3(0,0,0.6);
            dialBase.material = dialBaseMat;
            dialPointer.material = dialPointerMat;

            dialBasePos['x'] = position['x'];
            dialBasePos['y'] = baseScaling['y']/2;
            dialBasePos['z'] = position['z'] + 0.5*scaling;
            dialPointerPos['x'] = position['x'] -0.1;
            dialPointerPos['y'] = dialBasePos['y'] + dialPointerScaling['y']/2 - 0.24;
            dialPointerPos['z'] = position['z']+ 0.5*scaling;

            dialPointer.position = dialPointerPos;
            dialBase.position = dialBasePos;
            dialPointer.scaling = dialPointerScaling;
            dialBase.scaling = dialBaseScaling;

            dialPointer.actionManager = new BABYLON.ActionManager(scene);
            dialBase.actionManager = new BABYLON.ActionManager(scene);
            let currentPosition = {x: 0,y: 0 };
            let currentRotation = {x: 0,y: 0 };
            let clicked = false;
            let over = false;
            dialPointer.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickDownTrigger,
                    function() {
                        over = true;
                        camera.detachControl(canvas,false)
                    }
                )
            )
            dialPointer.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickOutTrigger,
                    function() {
                        over = false;
                        console.log((180/Math.PI)*dialPointer.rotation.y)
                        rotatingDialThresholdCheck(dialPointer.rotation.y);
                        camera.attachControl(canvas,true)
                    }
                )
            )

            dialBase.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickDownTrigger,
                    function() {
                        over = true;
                        camera.detachControl(canvas,false)

                    }
                )
            )
            dialBase.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickOutTrigger,
                    function() {
                        over = false;
                        console.log((180/Math.PI)*dialPointer.rotation.y)
                        rotatingDialThresholdCheck(dialPointer.rotation.y);
                        camera.attachControl(canvas,false)
                    }
                )
            )

            dialPointer.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickUpTrigger,
                    function() {
                        over = false;
                        console.log((180/Math.PI)*dialPointer.rotation.y)
                        rotatingDialThresholdCheck(dialPointer.rotation.y);
                        camera.attachControl(canvas,false)
                    }
                )
            )

            dialBase.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickUpTrigger,
                    function() {
                        over = false;
                        console.log((180/Math.PI)*dialPointer.rotation.y)
                        rotatingDialThresholdCheck(dialPointer.rotation.y);
                        camera.attachControl(canvas,false)
                    }
                )
            )

            canvas.addEventListener("pointerdown", function (evt) {
                currentPosition.x = evt.clientX;
                currentPosition.y = evt.clientY;
                currentRotation.x = dialPointer.rotation.x;
                currentRotation.y = dialPointer.rotation.y;
                clicked = true;
            });
            
            canvas.addEventListener("pointermove", function (evt) {
                if (!clicked) {
                    return;
                }
                if(over == true){
                    dialPointer.rotation.y = currentRotation.y + (evt.clientX - currentPosition.x) / 40.0;
                    if(dialPointer.rotation.y < 0){dialPointer.rotation.y = 0};
                    if(dialPointer.rotation.y > Math.PI){dialPointer.rotation.y = Math.PI}
                }
            });
            
            canvas.addEventListener("pointerup", function (evt) {
                clicked = false;
            });
           
            onHover(dialPointer,dialPointerMat,'blue');
                
            
        }

        function rotatingDialThresholdCheck(rotation){
            const offset = Math.PI*(15/180);
            const min = -0.1;
            const max = Math.PI+0.1;
            const minMid = Math.PI*(60/180);
            const maxMid = Math.PI*(120/180);
            if(rotation > min && rotation < offset){
                console.log('min')
            }
            else if(rotation > minMid-offset && rotation < minMid+offset){
                console.log('mid-min')
            }
            
            else if(rotation > maxMid-offset && rotation < maxMid+offset){
                console.log('mid-max')
            }
            
            else if(rotation > max-offset && rotation < max){
                console.log('max')
            }
        }
        
        function generateJoyStick(position, scaling, scene){
            const baseScaling = generateBase(scaling, position, 'diagonal');
            const joyStickBase = new BABYLON.MeshBuilder.CreateBox('joyStickBase',{});
            const joyStickBaseMat = new BABYLON.StandardMaterial('joyStickBaseMat');
            const joyStickBaseScaling = new BABYLON.Vector3(3*scaling,0.1,3*scaling);
            const joyStickBasePos = new BABYLON.Vector3(0,0,0);
            joyStickBasePos['x'] = position['x'];
            joyStickBasePos['y'] = baseScaling['y']/2;
            joyStickBasePos['z'] = position['z'] + 0.5*scaling;
            joyStickBaseMat.diffuseColor = new BABYLON.Color3(0,0,0);
            joyStickBase.material = joyStickBaseMat;
            joyStickBase.position = joyStickBasePos;
            joyStickBase.scaling = joyStickBaseScaling;

            const joyStick = new BABYLON.MeshBuilder.CreateBox('joyStick',{});
            const joyStickMat = new BABYLON.StandardMaterial('joyStickMat');
            const joyStickPos = new BABYLON.Vector3(0,0,0);
            const joyStickScaling = new BABYLON.Vector3(0.7,1,0.7);
            joyStickPos['x'] = position['x'];
            joyStickPos['y'] = baseScaling['y']/2 + joyStickScaling['y']/2;
            joyStickPos['z'] = position['z'] + 0.5*scaling;
            joyStickMat.diffuseColor = new BABYLON.Color3(0,0,0.6);
            joyStick.material = joyStickMat;
            joyStick.position = joyStickPos;
            joyStick.scaling = joyStickScaling;

            const points1 = [
                new BABYLON.Vector3(position['x']+joyStickBaseScaling['x']/2,joyStickBasePos['y']+joyStickBaseScaling['y']/2+0.01,position['z']-joyStickBaseScaling['z']/2+0.5*scaling),
                new BABYLON.Vector3(position['x']-joyStickBaseScaling['x']/2,joyStickBasePos['y']+joyStickBaseScaling['y']/2+0.01,position['z']+joyStickBaseScaling['z']/2+0.5*scaling),
            ]

            const points2 = [
                new BABYLON.Vector3(position['x']-joyStickBaseScaling['x']/2,joyStickBasePos['y']+joyStickBaseScaling['y']/2+0.01,position['z']-joyStickBaseScaling['z']/2+0.5*scaling),
                new BABYLON.Vector3(position['x']+joyStickBaseScaling['x']/2,joyStickBasePos['y']+joyStickBaseScaling['y']/2+0.01,position['z']+joyStickBaseScaling['z']/2+0.5*scaling),
            ]

            const points3 = [
                new BABYLON.Vector3(position['x'],joyStickBasePos['y']+joyStickBaseScaling['y']/2+0.01,position['z']-joyStickBaseScaling['z']/2+0.5*scaling),
                new BABYLON.Vector3(position['x'],joyStickBasePos['y']+joyStickBaseScaling['y']/2+0.01,position['z']+joyStickBaseScaling['z']/2+0.5*scaling),
            ]

            const points4 = [
                new BABYLON.Vector3(position['x']+joyStickBaseScaling['x']/2,joyStickBasePos['y']+joyStickBaseScaling['y']/2+0.01,position['z']+0.5*scaling),
                new BABYLON.Vector3(position['x']-joyStickBaseScaling['x']/2,joyStickBasePos['y']+joyStickBaseScaling['y']/2+0.01,position['z']+0.5*scaling),
            ]

            const line1 = BABYLON.MeshBuilder.CreateLines('line1',{points:points1});
            const line2 = BABYLON.MeshBuilder.CreateLines('line2',{points:points2});
            const line3 = BABYLON.MeshBuilder.CreateLines('line3',{points:points3});
            const line4 = BABYLON.MeshBuilder.CreateLines('line4',{points:points4});
            line1.color = new BABYLON.Color3(1,1,1);
            line2.color = new BABYLON.Color3(1,1,1);
            line3.color = new BABYLON.Color3(1,1,1);
            line4.color = new BABYLON.Color3(1,1,1);

            const lines = [line1,line2,line3,line4];

            joyStick.actionManager = new BABYLON.ActionManager(scene);
            const pointerDragBehavior = new BABYLON.PointerDragBehavior({dragPlaneNormal: new BABYLON.Vector3(0,1,0)});
            joyStick.addBehavior(pointerDragBehavior);
            onHover(joyStick,joyStickMat,'blue');
            const xMin = joyStickBasePos['x'] - joyStickBase.scaling['x']/2 + joyStick.scaling['x']/2
            const xMax = joyStickBasePos['x'] + joyStickBase.scaling['x']/2 - joyStick.scaling['x']/2
            const zMin = joyStickBasePos['z'] - joyStickBase.scaling['z']/2 + joyStick.scaling['z']/2
            const zMax = joyStickBasePos['z'] + joyStickBase.scaling['z']/2 - joyStick.scaling['z']/2
            const boundary = [xMin,xMax,zMin,zMax]
            pointerDragBehavior.onDragEndObservable.add((event)=>{
                let stickPos = {x:Math.round(joyStick.position['x']*100)/100,z:Math.round(joyStick.position['z']*100)/100}
                console.log(stickPos);
                joyStickThresholdCheck(stickPos,boundary,joyStickBasePos,lines)
                //console.log(event);
             })
            pointerDragBehavior.validateDrag = (targetPosition)=>{
               
                if(targetPosition.z < zMin){
                    targetPosition.z = zMin
                }
                
                if(targetPosition.x < xMin){
                    targetPosition.x = xMin
                }

                if(targetPosition.x > xMax){
                    targetPosition.x = xMax
                }

                if(targetPosition.z > zMax){
                    return false
                }else{
                    return true
                }
            
            }
        }

        function joyStickThresholdCheck(stickPos, boundary, position, lines){  
            const offSet = 0.1;
            const xMin = boundary[0];
            const xMax = boundary[1];
            const zMin = boundary[2];
            const zMax = boundary[3];

            if((stickPos['x'] > position['x']-offSet && stickPos['x'] < position['x']+offSet) && (stickPos['z'] == zMin || stickPos['z'] <= zMin+offSet)){
                console.log('north');
                lines[2].color = new BABYLON.Color3(1,0,0);
                lines[0].color = new BABYLON.Color3(1,1,1);
                lines[1].color = new BABYLON.Color3(1,1,1);
                lines[3].color = new BABYLON.Color3(1,1,1);
            }

            else if((stickPos['x'] >= position['x']-offSet && stickPos['x'] <= position['x']+offSet) && (stickPos['z'] == zMax || stickPos['z'] >= zMax-offSet)){
                console.log('south');
                lines[2].color = new BABYLON.Color3(1,0,0);
                lines[0].color = new BABYLON.Color3(1,1,1);
                lines[1].color = new BABYLON.Color3(1,1,1);
                lines[3].color = new BABYLON.Color3(1,1,1);
            }

            else if((stickPos['z'] >= position['z']-offSet && stickPos['z'] <= position['z']+offSet) && (stickPos['x'] == xMin || stickPos['x'] <= xMin+offSet)){
                console.log('east');
                lines[3].color = new BABYLON.Color3(1,0,0);
                lines[0].color = new BABYLON.Color3(1,1,1);
                lines[1].color = new BABYLON.Color3(1,1,1);
                lines[2].color = new BABYLON.Color3(1,1,1);
            }

            else if((stickPos['z'] >= position['z']-offSet && stickPos['z'] <= position['z']+offSet) && (stickPos['x'] == xMax || stickPos['x'] >= xMax-offSet)){
                console.log('west');
                lines[3].color = new BABYLON.Color3(1,0,0);
                lines[0].color = new BABYLON.Color3(1,1,1);
                lines[1].color = new BABYLON.Color3(1,1,1);
                lines[2].color = new BABYLON.Color3(1,1,1);
            }

            else if((stickPos['z'] == zMin || stickPos['z'] <= zMin+offSet) && (stickPos['x'] == xMax || stickPos['x'] >= xMax-offSet)){
                console.log('north-west');
                lines[0].color = new BABYLON.Color3(1,0,0);
                lines[1].color = new BABYLON.Color3(1,1,1);
                lines[2].color = new BABYLON.Color3(1,1,1);
                lines[3].color = new BABYLON.Color3(1,1,1);
            }

            else if((stickPos['z'] == zMax || stickPos['z'] >= zMax-offSet) && (stickPos['x'] == xMax || stickPos['x'] >= xMax-offSet)){
                console.log('south-west');
                lines[1].color = new BABYLON.Color3(1,0,0);
                lines[0].color = new BABYLON.Color3(1,1,1);
                lines[2].color = new BABYLON.Color3(1,1,1);
                lines[3].color = new BABYLON.Color3(1,1,1);
            }

            else if((stickPos['z'] == zMin || stickPos['z'] <= zMin+offSet) && (stickPos['x'] == xMin || stickPos['x'] <= xMin+offSet)){
                console.log('north-east');
                lines[1].color = new BABYLON.Color3(1,0,0);
                lines[0].color = new BABYLON.Color3(1,1,1);
                lines[2].color = new BABYLON.Color3(1,1,1);
                lines[3].color = new BABYLON.Color3(1,1,1);
            }

            else if((stickPos['z'] == zMax || stickPos['z'] >= zMax-offSet) && (stickPos['x'] == xMin || stickPos['x'] <= xMin+offSet)){
                console.log('south-east');
                lines[0].color = new BABYLON.Color3(1,0,0);
                lines[1].color = new BABYLON.Color3(1,1,1);
                lines[2].color = new BABYLON.Color3(1,1,1);
                lines[3].color = new BABYLON.Color3(1,1,1);
            }
            else{
                lines[0].color = new BABYLON.Color3(1,1,1);
                lines[1].color = new BABYLON.Color3(1,1,1);
                lines[2].color = new BABYLON.Color3(1,1,1);
                lines[3].color = new BABYLON.Color3(1,1,1);
            }
        }

        function onHover(mesh, material, color){
            mesh.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPointerOverTrigger,
                    function(){
                        if(color == 'blue'){
                            material.diffuseColor = new BABYLON.Color3(0,0,1);
                        }
                        else if(color == 'red'){
                            material.diffuseColor = new BABYLON.Color3(1,0,0);
                        }
                        else if(color == 'green'){
                            material.diffuseColor = new BABYLON.Color3(0,1,0);
                        }
                        else if(color == 'yellow'){
                            material.diffuseColor = new BABYLON.Color3(1,1,0);
                        }
                    }
                )
            );
            mesh.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPointerOutTrigger,
                    function(){
                        const curColor = material.diffuseColor;
                        if(color == 'blue'){
                            material.diffuseColor = new BABYLON.Color3(0,0,0.6);
                        }
                        else if(color == 'red'){
                            material.diffuseColor = new BABYLON.Color3(0.6,0,0);
                        }
                        else if(color == 'green'){
                            material.diffuseColor = new BABYLON.Color3(0,0.6,0);
                        }
                        else if(color == 'yellow'){
                            material.diffuseColor = new BABYLON.Color3(0.6,0.6,0);
                        }
                    }
                ),
                
            );
        }
        
        

        function generateBaseBig(){
            const base = new BABYLON.MeshBuilder.CreateBox("box",{width:15,depth:15});
            const points1 = [
                new BABYLON.Vector3(-7.5,0.51,2.5),
                new BABYLON.Vector3(7.5,0.51,2.5),
                new BABYLON.Vector3(7.5,0.51,-2.5),
                new BABYLON.Vector3(-7.5,0.51,-2.5),
                ];
            points1.push(points1[0]);
            const line1 = BABYLON.MeshBuilder.CreateLines("lines1",{points:points1});
            line1.color = new BABYLON.Color3(0,0,0);

            const points2 = [
                new BABYLON.Vector3(-2.5,0.51,7.5),
                new BABYLON.Vector3(2.5,0.51,7.5),
                new BABYLON.Vector3(2.5,0.51,-7.5),
                new BABYLON.Vector3(-2.5,0.51,-7.5),
                ];
            points2.push(points2[0]);
            const line2 = BABYLON.MeshBuilder.CreateLines("lines2",{points:points2});
            line2.color = new BABYLON.Color3(0,0,0);

            return base;
        }
        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
                scene.render();
        });

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });
    </script>

   </body>

</html>