<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Babylon Template</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>

        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    </head>

   <body>

    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

    <script>
        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

        // Add your code here matching the playground format
        const createScene = function () {
    
            const scene = new BABYLON.Scene(engine);
            //const base = generateBaseBig();
            const buttonPos = new BABYLON.Vector3(0,0,5);
            const buttonScale = 1;
            const sliderPos = new BABYLON.Vector3(5,0,0);
            const sliderScale = 3;
            const sequenceButtonPos = new BABYLON.Vector3(0,0,0);
            const sequenceButtonScale = 1;
            const leverPos = new BABYLON.Vector3(-5,0,5);
            const leverScale = 1;
            const rotatingDialPos = new BABYLON.Vector3(-5,0,0);
            const rotatingDialScale = 1;
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0));
            camera.attachControl(canvas,true);
            camera.setPosition(new BABYLON.Vector3(0, 20, 0));
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));
            generateRotatingDial(rotatingDialPos,rotatingDialScale,scene,camera);
            generateLever(leverPos,leverScale,scene,'diagonal');
            generateSequenceButton(sequenceButtonPos,sequenceButtonScale,scene);
            generateButton(buttonPos,buttonScale,scene);
            generateSlider(sliderPos,sliderScale,scene,'vertical');
            
            
            return scene;
        };

        const scene = createScene(); //Call the createScene function
        
        function generateButton(position, scaling, scene){
            const button = new BABYLON.MeshBuilder.CreateCylinder("button",{});
            const buttonMat = new BABYLON.StandardMaterial("buttonMat");
            const buttonScaling = new BABYLON.Vector3(3*scaling,0.5,3*scaling)
            const buttonPos = new BABYLON.Vector3(0,0,0);
            buttonPos['x'] = position['x'];
            buttonPos['y'] = buttonScaling['y'];
            buttonPos['z'] = position['z'];
            buttonPos['z'] += 0.5*scaling;
            buttonMat.diffuseColor = new BABYLON.Color3(0,0,0.6);
            button.material = buttonMat;
            button.position = buttonPos;
            button.scaling = buttonScaling;

            generateBase(scaling,position,'diagonal');
            button.actionManager = new BABYLON.ActionManager(scene);
            let downFlag = false;
            button.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function () {
                        console.log('cum');
                        scene.registerBeforeRender(buttonCallback);
                    }
                )
            );
            
            function buttonCallback(){
                if(downFlag == false){
                    button.position.y -= 0.01;
                    if(button.position.y < 0.2){downFlag = true}
                }
                else{
                    button.position.y += 0.01;
                    if(button.position.y > 0.4){
                        downFlag = false;
                        scene.unregisterBeforeRender(buttonCallback);}
                }
            }
            onHover(button,buttonMat,'blue');

        }

        function generateBase(scaling,position,type){
            const base = new BABYLON.MeshBuilder.CreateBox("base",{});
            const baseScaling = new BABYLON.Vector3(5,1,5);
            if(type == "diagonal"){
                baseScaling['x'] *= scaling;
                baseScaling['z'] *= scaling;
            }
            else if(type == 'horizontal'){
                baseScaling['x'] *= scaling;
            }
            else if(type == "vertical"){
                baseScaling['z'] *= scaling;
            }
            const baseMat = new BABYLON.StandardMaterial("baseMat");
            baseMat.diffuseColor = new BABYLON.Color3(1,1,1);
            base.position = position;
            base.scaling = baseScaling;
            base.material = baseMat;
            
            const points = [
                new BABYLON.Vector3(position['x']-baseScaling['x']/2,position['y']+baseScaling['y']/2,position['z']-baseScaling['z']/2),
                new BABYLON.Vector3(position['x']-baseScaling['x']/2,position['y']+baseScaling['y']/2,position['z']+baseScaling['z']/2),
                new BABYLON.Vector3(position['x']+baseScaling['x']/2,position['y']+baseScaling['y']/2,position['z']+baseScaling['z']/2),
                new BABYLON.Vector3(position['x']+baseScaling['x']/2,position['y']+baseScaling['y']/2,position['z']-baseScaling['z']/2),
                ];
            points.push(points[0]);
            const outline = BABYLON.MeshBuilder.CreateLines("outline",{points:points});
            outline.color = new BABYLON.Color3(0,0,0);
            return baseScaling;
        }

        function generateSlider(position, scaling, scene, orientation){
            const sliderBase = new BABYLON.MeshBuilder.CreateBox("sliderBase",{});
            const sliderBaseMat = new BABYLON.StandardMaterial("sliderBaseMat");
            const sliderBaseScaling = new BABYLON.Vector3(1,0.5,1);
            if(orientation == 'vertical'){
                sliderBaseScaling['z'] *= scaling*3
            } else {
                sliderBaseScaling['x'] *= scaling*3
            }
            const sliderBasePos = new BABYLON.Vector3(0,0,0);
            sliderBasePos['x'] = position['x'];
            sliderBasePos['y'] = position['y']+sliderBaseScaling['y'];
            sliderBasePos['z'] = position['z'];


            const points = (orientation=='vertical')?
            [
                new BABYLON.Vector3(position['x']+sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']),
                new BABYLON.Vector3(position['x']-sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']),
            ]:[
                new BABYLON.Vector3(position['x'],sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']+sliderBaseScaling['z']/2),
                new BABYLON.Vector3(position['x'],sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']-sliderBaseScaling['z']/2),
            ]

            const midLine = BABYLON.MeshBuilder.CreateLines("midLine",{points:points});
            midLine.color = new BABYLON.Color3(1,0,0);
            sliderBaseMat.diffuseColor = new BABYLON.Color3(0,0,0);
            sliderBase.material = sliderBaseMat;
            sliderBase.position = sliderBasePos;
            sliderBase.scaling = sliderBaseScaling;


            const sliderButton = new BABYLON.MeshBuilder.CreateBox("sliderButton",{});
            const sliderButtonMat = new BABYLON.StandardMaterial("sliderButtonMat");
            const sliderButtonScaling = new BABYLON.Vector3(1,0.2,1);

            const maxValue = (orientation == 'vertical')? position['z']-sliderButton.scaling['z']/2+(sliderBase.scaling['z'])/2:position['x']-sliderButton.scaling['x']/2+(sliderBase.scaling['x'])/2
            const minValue = (orientation == 'vertical')? position['z']+sliderButton.scaling['z']/2-(sliderBase.scaling['z'])/2:position['x']+sliderButton.scaling['x']/2-(sliderBase.scaling['x'])/2
            const midValue = (orientation == 'vertical')? position['z']:position['x']
            const interval = (maxValue+sliderButtonScaling['x']/2-midValue)/2
            
            if(scaling != 1){
                const points1 = (orientation == 'vertical')?
                [
                new BABYLON.Vector3(position['x']+sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,midValue + interval),
                new BABYLON.Vector3(position['x']-sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,midValue + interval),
            ]:[
                new BABYLON.Vector3(midValue + interval,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']+sliderBaseScaling['z']/2),
                new BABYLON.Vector3(midValue + interval,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']-sliderBaseScaling['z']/2),
            ];
            
                const points2 = (orientation == 'vertical')?
                [
                new BABYLON.Vector3(position['x']+sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,midValue - interval),
                new BABYLON.Vector3(position['x']-sliderBaseScaling['x']/2,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,midValue - interval),
            ]:[
                new BABYLON.Vector3(midValue - interval,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']+sliderBaseScaling['z']/2),
                new BABYLON.Vector3(midValue - interval,sliderBasePos['y']+sliderBaseScaling['y']/2+0.01,position['z']-sliderBaseScaling['z']/2),
            ];

            const midMaxLine = BABYLON.MeshBuilder.CreateLines("midLine",{points:points1});
            const midMinLine = BABYLON.MeshBuilder.CreateLines("midMinLine",{points:points2})
            midMinLine.color = new BABYLON.Color3(1,0,0);
            midMaxLine.color = new BABYLON.Color3(1,0,0);
            }

            sliderButtonMat.diffuseColor = new BABYLON.Color3(0,0,0.6);
            sliderButton.material = sliderButtonMat;
            sliderButton.scaling = sliderButtonScaling;
            sliderButton.position = new BABYLON.Vector3(position['x'],sliderBasePos['y']+sliderBase.scaling['y']/2+sliderButton.scaling['y']/2,position['z']);
            sliderButton.actionManager = new BABYLON.ActionManager(scene);
            onHover(sliderButton,sliderButtonMat,'blue')

            if(orientation=='horizontal'){
                generateBase(scaling,position,'horizontal');
            } else {
                generateBase(scaling,position,'vertical');

            }
            const pointerDragBehavior = (orientation == "vertical")? new BABYLON.PointerDragBehavior({dragAxis: new BABYLON.Vector3(0,0,1)}):new BABYLON.PointerDragBehavior({dragAxis: new BABYLON.Vector3(1,0,0)});
            sliderButton.addBehavior(pointerDragBehavior);
            
            pointerDragBehavior.onDragEndObservable.add((event)=>{
                let sliderPos = (orientation == 'vertical')? Math.round((sliderButton.position['z'])*10)/10 : Math.round(sliderButton.position['x']*10)/10;
                console.log(sliderPos)
                // Do something if certain threshold is met
                sliderThresholdCheck(sliderPos,scaling,maxValue,minValue, midValue,interval);
                console.log(event);
             })
            pointerDragBehavior.validateDrag = (targetPosition)=>{
                if(orientation == 'vertical'){
                    if(targetPosition.z < minValue){
                        targetPosition.z = minValue
                    }
                    
                    if(targetPosition.z > maxValue){
                        return false
                    }else{
                        return true
                    }
            } else {
                if(targetPosition.x < minValue){
                        targetPosition.x = minValue
                    }
                    
                    if(targetPosition.x > maxValue){
                        return false
                    }else{
                        return true
                    }
            }
            }
        }

        function sliderThresholdCheck(sliderPos, scaling, maxValue, minValue, midValue, interval){
            const offSet = 0.2;
            
            if(sliderPos <= midValue+offSet && sliderPos >= midValue-offSet){
                console.log('mid');
            }

            else if(sliderPos == minValue){
                console.log('min')
            }

            else if(sliderPos == maxValue){
                console.log('max')
            }

            else if(scaling != 1){
                if(sliderPos <= midValue+offSet+interval && sliderPos >= midValue+interval-offSet){
                    console.log('mid-max')
                }
                if(sliderPos <= midValue+offSet-interval && sliderPos >= midValue-interval-offSet){
                    console.log('mid-min')
                }
            }

        }

        function generateSequenceButton(position, scaling, scene){
            generateBase(scaling,position,'diagonal');
            const redButton = new BABYLON.MeshBuilder.CreateBox('redButton',{});
            const greenButton = new BABYLON.MeshBuilder.CreateBox('greenButton',{});
            const yellowButton = new BABYLON.MeshBuilder.CreateBox('yellowButton',{});
            const blueButton = new BABYLON.MeshBuilder.CreateBox('blueButton',{});
            let sequenceButton = [];
            sequenceButton.push(redButton);
            sequenceButton.push(greenButton);
            sequenceButton.push(yellowButton);
            sequenceButton.push(blueButton);
            const redButtonMat = new BABYLON.StandardMaterial("redButtonMat");
            const greenButtonMat = new BABYLON.StandardMaterial("greenButtonMat");
            const yellowButtonMat = new BABYLON.StandardMaterial("yellowButtonMat");
            const blueButtonMat = new BABYLON.StandardMaterial("blueButtonMat");
            redButtonMat.diffuseColor = new BABYLON.Color3(0.5,0,0);
            greenButtonMat.diffuseColor = new BABYLON.Color3(0,0.5,0);
            yellowButtonMat.diffuseColor = new BABYLON.Color3(0.5,0.5,0);
            blueButtonMat.diffuseColor = new BABYLON.Color3(0,0,0.5);
            let sequenceButtonMat = [];
            sequenceButtonMat.push(redButtonMat);
            sequenceButtonMat.push(greenButtonMat);
            sequenceButtonMat.push(yellowButtonMat);
            sequenceButtonMat.push(blueButtonMat);
            
            for(let i = 0; i < sequenceButton.length; i++){
                sequenceButton[i].material = sequenceButtonMat[i];
            }
            
            
            const sequenceButtonScaling = new BABYLON.Vector3(1.5*scaling,0.5,1.5*scaling);

            for(let i = 0; i < sequenceButton.length; i++){
                sequenceButton[i].scaling = sequenceButtonScaling;
            }
            
            let sequenceButtonPos = [];
            sequenceButtonPos.push(new BABYLON.Vector3(position['x']+sequenceButtonScaling['x']/2,sequenceButtonScaling['y'],position['z']-sequenceButtonScaling['z']/2));
            sequenceButtonPos.push(new BABYLON.Vector3(position['x']+sequenceButtonScaling['x']/2,sequenceButtonScaling['y'],position['z']+sequenceButtonScaling['z']/2));
            sequenceButtonPos.push(new BABYLON.Vector3(position['x']-sequenceButtonScaling['x']/2,sequenceButtonScaling['y'],position['z']+sequenceButtonScaling['z']/2));
            sequenceButtonPos.push(new BABYLON.Vector3(position['x']-sequenceButtonScaling['x']/2,sequenceButtonScaling['y'],position['z']-sequenceButtonScaling['z']/2));
            
            for(let i = 0; i < sequenceButton.length;i++){
                let randomPos = sequenceButtonPos[Math.floor(Math.random() * sequenceButtonPos.length)];
                sequenceButton[i].position = randomPos;
                sequenceButtonPos = sequenceButtonPos.filter(function(e){return e != randomPos});
                sequenceButton[i].actionManager = new BABYLON.ActionManager(scene);
            }
            
            let userSequence = [];
            let result = 0;
            
            redButton.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function(){
                        if(userSequence.includes('red') == false){
                            redButtonMat.diffuseColor = new BABYLON.Color3(1,0,0);
                            userSequence.push('red');
                            userSequence = submitSequenceResult(userSequence, sequenceButtonMat);    
                        }
                    }
                )
            );
            greenButton.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function(){
                        if(userSequence.includes('green') == false){
                            greenButtonMat.diffuseColor = new BABYLON.Color3(0,1,0);
                            userSequence.push('green');
                            userSequence = submitSequenceResult(userSequence, sequenceButtonMat);    
                        }
                    }
                )
            );
            yellowButton.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function(){
                        if(userSequence.includes('yellow') == false){
                            yellowButtonMat.diffuseColor = new BABYLON.Color3(1,1,0);
                            userSequence.push('yellow');
                            userSequence = submitSequenceResult(userSequence, sequenceButtonMat);    
                        }
                    }
                )
            );
            blueButton.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function(){
                        if(userSequence.includes('blue') == false){
                            blueButtonMat.diffuseColor = new BABYLON.Color3(0,0,1);
                            userSequence.push('blue');
                            userSequence = submitSequenceResult(userSequence, sequenceButtonMat);
                            
                        }
                    }
                )
            );
        }

        function submitSequenceResult(userSequence, sequenceButtonMat){
            if(userSequence.length == 4){
                sequenceButtonMat[0].diffuseColor = new BABYLON.Color3(0.5,0,0);
                sequenceButtonMat[1].diffuseColor = new BABYLON.Color3(0,0.5,0);
                sequenceButtonMat[2].diffuseColor = new BABYLON.Color3(0.5,0.5,0);
                sequenceButtonMat[3].diffuseColor = new BABYLON.Color3(0,0,0.5);
            
                console.log(userSequence);
                userSequence = [];
                return userSequence;
            } else {return userSequence;}
        }
        
        function generateLever(position, scaling, scene, orientation){
            const baseScaling = generateBase(scaling,position,orientation);
            const lever = new BABYLON.MeshBuilder.CreateBox('lever',{});
            const leverMat = new BABYLON.StandardMaterial('leverMat');
            const leverPos = new BABYLON.Vector3(0,0,0);
            const leverScaling = new BABYLON.Vector3(3,0.4,1);
            if(orientation == 'diagonal'){
                leverScaling['x'] *= scaling;
                leverScaling['z'] *= scaling;
            } else if(orientation == 'vertical'){
                leverScaling['z'] *= scaling;
            } else {leverScaling['x'] *= scaling}
            
            let leverState = 0;
            leverPos['x'] = position['x']
            leverPos['y'] = leverScaling['y']
            leverPos['z'] = position['z']
            leverMat.diffuseColor = new BABYLON.Color3(0,0,0.6);
            lever.material = leverMat;
            lever.position = leverPos;
            lever.scaling = leverScaling;
            lever.rotation.z = Math.PI*(30/180);
            const leverStatus = new BABYLON.MeshBuilder.CreateSphere("sphere", {slice: 0.5, sideOrientation: BABYLON.Mesh.DOUBLESIDE});
            const leverStatusMat = new BABYLON.StandardMaterial('leverStatusMat');
            leverStatusMat.diffuseColor = new BABYLON.Color3(1,0,0);
            leverStatus.material = leverStatusMat;
            const leverStatusPos = new BABYLON.Vector3(0,0,0);
            leverStatusPos['x'] = position['x'] - baseScaling['x']/2 + 0.5*scaling
            leverStatusPos['y'] = lever.scaling['y']-0.2
            leverStatusPos['z'] = position['z'] + baseScaling['z']/2 - 0.5*scaling
            leverStatus.position = leverStatusPos;

            lever.actionManager = new BABYLON.ActionManager(scene);
            lever.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function () {
                        if(leverState == 0){
                            leverState = 1;
                            leverStatusMat.diffuseColor = new BABYLON.Color3(0,1,0);
                            console.log('yummy');
                            scene.registerBeforeRender(leverCallback);
                        }
                        else {
                            leverState = 0;
                            leverStatusMat.diffuseColor = new BABYLON.Color3(1,0,0);
                            console.log('tummy');
                            scene.registerBeforeRender(leverCallback);
                        }
                    }
                )
            );
            function leverCallback(){
                if(leverState == 1){
                    lever.rotation.z += Math.PI*(10/180);
                    if(lever.rotation.z > Math.PI*(150/180)){
                        scene.unregisterBeforeRender(leverCallback);
                    }
                } else{
                    lever.rotation.z -= Math.PI*(10/180);;
                    if(lever.rotation.z < Math.PI*(30/180)){
                        scene.unregisterBeforeRender(leverCallback);
                    }
                }
            }
            onHover(lever,leverMat,'blue');




        }
        
        function generateRotatingDial(position, scaling, scene,camera){
            generateBase(scaling,position,'diagonal');
            const dialBase = new BABYLON.MeshBuilder.CreateCylinder("dialBase",{})
            const dialPointer = new BABYLON.MeshBuilder.CreateBox("dialPointer",{});
            const dialPointerScaling = new BABYLON.Vector3(2.3*scaling,0.5,0.4*scaling);
            const dialBaseScaling = new BABYLON.Vector3(2.3*scaling,0.4,2.3*scaling);
            const dialPointerPos = new BABYLON.Vector3(0,0,0);
            const dialBasePos = new BABYLON.Vector3(0,0,0);
            const dialBaseMat = new BABYLON.StandardMaterial('dialBaseMat');
            const dialPointerMat = new BABYLON.StandardMaterial('dialPointerMat');

            dialBaseMat.diffuseColor = new BABYLON.Color3(0,0,0);
            dialPointerMat.diffuseColor = new BABYLON.Color3(0,0,0.6);
            dialBase.material = dialBaseMat;
            dialPointer.material = dialPointerMat;

            dialBasePos['x'] = position['x'];
            dialBasePos['y'] = dialBaseScaling['y'];
            dialBasePos['z'] = position['z'] + 0.5*scaling;
            dialPointerPos['x'] = position['x'];
            dialPointerPos['y'] = dialPointerScaling['y'] + dialBasePos['y']/2;
            dialPointerPos['z'] = position['z']+ 0.5*scaling;
            dialPointer.rotation.z = Math.PI*(10/180);

            dialPointer.position = dialPointerPos;
            dialBase.position = dialBasePos;
            dialPointer.scaling = dialPointerScaling;
            dialBase.scaling = dialBaseScaling;
            
            
        }

        function onHover(mesh, material, color){
            mesh.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPointerOverTrigger,
                    function(){
                        if(color == 'blue'){
                            material.diffuseColor = new BABYLON.Color3(0,0,1);
                        }
                        else if(color == 'red'){
                            material.diffuseColor = new BABYLON.Color3(1,0,0);
                        }
                        else if(color == 'green'){
                            material.diffuseColor = new BABYLON.Color3(0,1,0);
                        }
                        else if(color == 'yellow'){
                            material.diffuseColor = new BABYLON.Color3(1,1,0);
                        }
                    }
                )
            );
            mesh.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPointerOutTrigger,
                    function(){
                        const curColor = material.diffuseColor;
                        if(color == 'blue'){
                            material.diffuseColor = new BABYLON.Color3(0,0,0.6);
                        }
                        else if(color == 'red'){
                            material.diffuseColor = new BABYLON.Color3(0.6,0,0);
                        }
                        else if(color == 'green'){
                            material.diffuseColor = new BABYLON.Color3(0,0.6,0);
                        }
                        else if(color == 'yellow'){
                            material.diffuseColor = new BABYLON.Color3(0.6,0.6,0);
                        }
                    }
                ),
                
            );
        }
        
        

        function generateBaseBig(){
            const base = new BABYLON.MeshBuilder.CreateBox("box",{width:15,depth:15});
            const points1 = [
                new BABYLON.Vector3(-7.5,0.51,2.5),
                new BABYLON.Vector3(7.5,0.51,2.5),
                new BABYLON.Vector3(7.5,0.51,-2.5),
                new BABYLON.Vector3(-7.5,0.51,-2.5),
                ];
            points1.push(points1[0]);
            const line1 = BABYLON.MeshBuilder.CreateLines("lines1",{points:points1});
            line1.color = new BABYLON.Color3(0,0,0);

            const points2 = [
                new BABYLON.Vector3(-2.5,0.51,7.5),
                new BABYLON.Vector3(2.5,0.51,7.5),
                new BABYLON.Vector3(2.5,0.51,-7.5),
                new BABYLON.Vector3(-2.5,0.51,-7.5),
                ];
            points2.push(points2[0]);
            const line2 = BABYLON.MeshBuilder.CreateLines("lines2",{points:points2});
            line2.color = new BABYLON.Color3(0,0,0);

            return base;
        }
        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
                scene.render();
        });

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });
    </script>

   </body>

</html>